//! doctor::fixes
//!
//! Fix option types for the Doctor framework.
//!
//! # Architecture
//!
//! Per ARCHITECTURE.md Section 8.2, a `FixOption` contains:
//! - `FixId` (stable identifier)
//! - Preconditions (capabilities that must remain true at apply time)
//! - A plan preview (ref changes and operations)
//! - A concrete repair plan
//!
//! Fix options are generated by fix generators based on detected issues.
//! The Doctor presents these options to the user and only applies them
//! with explicit confirmation.

use std::fmt;

use crate::engine::capabilities::Capability;
use crate::engine::health::IssueId;
use crate::engine::plan::Plan;

/// A stable identifier for a fix option.
///
/// Fix IDs are deterministic and can be used to reference fixes
/// in non-interactive mode (e.g., `lattice doctor --fix <fix-id>`).
///
/// # Example
///
/// ```
/// use lattice::doctor::FixId;
///
/// let id = FixId::new("trunk-not-configured", "set-trunk", "main");
/// assert!(id.as_str().contains("set-trunk"));
/// ```
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FixId(String);

impl FixId {
    /// Create a new fix ID from issue type, fix type, and optional key.
    ///
    /// Format: `{issue_type}:{fix_type}:{key}` or `{issue_type}:{fix_type}` if no key.
    pub fn new(issue_type: &str, fix_type: &str, key: &str) -> Self {
        if key.is_empty() {
            Self(format!("{}:{}", issue_type, fix_type))
        } else {
            Self(format!("{}:{}:{}", issue_type, fix_type, key))
        }
    }

    /// Create a fix ID without a key component.
    pub fn simple(issue_type: &str, fix_type: &str) -> Self {
        Self::new(issue_type, fix_type, "")
    }

    /// Get the string representation of the fix ID.
    pub fn as_str(&self) -> &str {
        &self.0
    }

    /// Parse a fix ID from a string.
    pub fn parse(s: &str) -> Self {
        Self(s.to_string())
    }
}

impl fmt::Display for FixId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

/// A change to a Git ref.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum RefChange {
    /// Create a new ref.
    Create {
        /// Full ref name (e.g., `refs/heads/main`).
        ref_name: String,
        /// New OID to set.
        new_oid: String,
    },
    /// Update an existing ref.
    Update {
        /// Full ref name.
        ref_name: String,
        /// Expected old OID (for CAS).
        old_oid: Option<String>,
        /// New OID to set.
        new_oid: String,
    },
    /// Delete a ref.
    Delete {
        /// Full ref name.
        ref_name: String,
        /// Expected old OID (for CAS).
        old_oid: String,
    },
}

impl fmt::Display for RefChange {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            RefChange::Create { ref_name, new_oid } => {
                write!(
                    f,
                    "create {} -> {}",
                    ref_name,
                    &new_oid[..8.min(new_oid.len())]
                )
            }
            RefChange::Update {
                ref_name,
                old_oid,
                new_oid,
            } => {
                let old = old_oid
                    .as_ref()
                    .map(|o| &o[..8.min(o.len())])
                    .unwrap_or("(any)");
                write!(
                    f,
                    "update {} {} -> {}",
                    ref_name,
                    old,
                    &new_oid[..8.min(new_oid.len())]
                )
            }
            RefChange::Delete { ref_name, old_oid } => {
                write!(
                    f,
                    "delete {} (was {})",
                    ref_name,
                    &old_oid[..8.min(old_oid.len())]
                )
            }
        }
    }
}

/// A change to branch metadata.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum MetadataChange {
    /// Create metadata for a branch.
    Create {
        /// Branch name.
        branch: String,
        /// Description of the metadata being created.
        description: String,
    },
    /// Update existing metadata.
    Update {
        /// Branch name.
        branch: String,
        /// Field being updated.
        field: String,
        /// Old value (if known).
        old_value: Option<String>,
        /// New value.
        new_value: String,
    },
    /// Delete metadata for a branch.
    Delete {
        /// Branch name.
        branch: String,
    },
}

impl fmt::Display for MetadataChange {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            MetadataChange::Create {
                branch,
                description,
            } => {
                write!(f, "create metadata for '{}': {}", branch, description)
            }
            MetadataChange::Update {
                branch,
                field,
                old_value,
                new_value,
            } => {
                let old = old_value.as_deref().unwrap_or("(unset)");
                write!(f, "update '{}' {}: {} -> {}", branch, field, old, new_value)
            }
            MetadataChange::Delete { branch } => {
                write!(f, "delete metadata for '{}'", branch)
            }
        }
    }
}

/// A change to configuration.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ConfigChange {
    /// Set a config value.
    Set {
        /// Config key.
        key: String,
        /// New value.
        value: String,
    },
    /// Remove a config value.
    Remove {
        /// Config key.
        key: String,
    },
    /// Migrate config file location.
    Migrate {
        /// Old path.
        from: String,
        /// New path.
        to: String,
    },
}

impl fmt::Display for ConfigChange {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ConfigChange::Set { key, value } => {
                write!(f, "set {} = {}", key, value)
            }
            ConfigChange::Remove { key } => {
                write!(f, "remove {}", key)
            }
            ConfigChange::Migrate { from, to } => {
                write!(f, "migrate {} -> {}", from, to)
            }
        }
    }
}

/// A preview of what a fix will do.
///
/// This is shown to the user before they confirm applying a fix.
#[derive(Debug, Clone, Default)]
pub struct FixPreview {
    /// Ref changes that will be made.
    pub ref_changes: Vec<RefChange>,
    /// Metadata changes that will be made.
    pub metadata_changes: Vec<MetadataChange>,
    /// Config changes that will be made.
    pub config_changes: Vec<ConfigChange>,
    /// Human-readable summary of the fix.
    pub summary: String,
}

impl FixPreview {
    /// Create a new empty preview.
    pub fn new() -> Self {
        Self::default()
    }

    /// Create a preview with a summary.
    pub fn with_summary(summary: impl Into<String>) -> Self {
        Self {
            summary: summary.into(),
            ..Default::default()
        }
    }

    /// Add a ref change to the preview.
    pub fn add_ref_change(mut self, change: RefChange) -> Self {
        self.ref_changes.push(change);
        self
    }

    /// Add a metadata change to the preview.
    pub fn add_metadata_change(mut self, change: MetadataChange) -> Self {
        self.metadata_changes.push(change);
        self
    }

    /// Add a config change to the preview.
    pub fn add_config_change(mut self, change: ConfigChange) -> Self {
        self.config_changes.push(change);
        self
    }

    /// Check if this preview has any changes.
    pub fn has_changes(&self) -> bool {
        !self.ref_changes.is_empty()
            || !self.metadata_changes.is_empty()
            || !self.config_changes.is_empty()
    }

    /// Get the total number of changes.
    pub fn change_count(&self) -> usize {
        self.ref_changes.len() + self.metadata_changes.len() + self.config_changes.len()
    }

    /// Format the preview for display.
    pub fn format(&self) -> String {
        let mut lines = Vec::new();

        if !self.summary.is_empty() {
            lines.push(self.summary.clone());
        }

        if !self.ref_changes.is_empty() {
            lines.push("  Ref changes:".to_string());
            for change in &self.ref_changes {
                lines.push(format!("    - {}", change));
            }
        }

        if !self.metadata_changes.is_empty() {
            lines.push("  Metadata changes:".to_string());
            for change in &self.metadata_changes {
                lines.push(format!("    - {}", change));
            }
        }

        if !self.config_changes.is_empty() {
            lines.push("  Config changes:".to_string());
            for change in &self.config_changes {
                lines.push(format!("    - {}", change));
            }
        }

        lines.join("\n")
    }
}

/// A fix option for an issue.
///
/// Represents a concrete action that can be taken to resolve an issue.
/// Doctor presents these to the user and only applies them with explicit
/// confirmation (per ARCHITECTURE.md Section 8.3).
#[derive(Debug, Clone)]
pub struct FixOption {
    /// Stable identifier for this fix.
    pub id: FixId,
    /// The issue this fix addresses.
    pub issue_id: IssueId,
    /// Human-readable description of what this fix does.
    pub description: String,
    /// Preview of what changes will be made.
    pub preview: FixPreview,
    /// Capabilities required at apply time.
    ///
    /// These are checked before applying to ensure the fix is still valid.
    pub preconditions: Vec<Capability>,
    /// The concrete plan to execute (generated lazily).
    ///
    /// This is None until the fix is selected for application.
    plan: Option<Plan>,
}

impl FixOption {
    /// Create a new fix option.
    ///
    /// # Example
    ///
    /// ```
    /// use lattice::doctor::{FixOption, FixId, FixPreview};
    /// use lattice::engine::health::IssueId;
    ///
    /// let fix = FixOption::new(
    ///     FixId::simple("trunk-not-configured", "set-trunk"),
    ///     IssueId::singleton("trunk-not-configured"),
    ///     "Set trunk to 'main'",
    ///     FixPreview::with_summary("Configure main as the trunk branch"),
    /// );
    ///
    /// assert_eq!(fix.description, "Set trunk to 'main'");
    /// ```
    pub fn new(
        id: FixId,
        issue_id: IssueId,
        description: impl Into<String>,
        preview: FixPreview,
    ) -> Self {
        Self {
            id,
            issue_id,
            description: description.into(),
            preview,
            preconditions: Vec::new(),
            plan: None,
        }
    }

    /// Add a precondition capability.
    pub fn with_precondition(mut self, cap: Capability) -> Self {
        self.preconditions.push(cap);
        self
    }

    /// Add multiple precondition capabilities.
    pub fn with_preconditions(mut self, caps: impl IntoIterator<Item = Capability>) -> Self {
        self.preconditions.extend(caps);
        self
    }

    /// Set the concrete plan for this fix.
    pub fn with_plan(mut self, plan: Plan) -> Self {
        self.plan = Some(plan);
        self
    }

    /// Get the plan if one has been set.
    pub fn plan(&self) -> Option<&Plan> {
        self.plan.as_ref()
    }

    /// Take the plan out of this fix option.
    pub fn take_plan(&mut self) -> Option<Plan> {
        self.plan.take()
    }

    /// Check if this fix has a concrete plan.
    pub fn has_plan(&self) -> bool {
        self.plan.is_some()
    }

    /// Check if all preconditions are satisfied.
    pub fn preconditions_satisfied(
        &self,
        caps: &crate::engine::capabilities::CapabilitySet,
    ) -> bool {
        self.preconditions.iter().all(|c| caps.has(c))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    mod fix_id {
        use super::*;

        #[test]
        fn new_with_key() {
            let id = FixId::new("issue", "fix", "key");
            assert_eq!(id.as_str(), "issue:fix:key");
        }

        #[test]
        fn new_without_key() {
            let id = FixId::new("issue", "fix", "");
            assert_eq!(id.as_str(), "issue:fix");
        }

        #[test]
        fn simple() {
            let id = FixId::simple("issue", "fix");
            assert_eq!(id.as_str(), "issue:fix");
        }

        #[test]
        fn display() {
            let id = FixId::new("issue", "fix", "key");
            assert_eq!(format!("{}", id), "issue:fix:key");
        }

        #[test]
        fn parse() {
            let id = FixId::parse("custom:id:format");
            assert_eq!(id.as_str(), "custom:id:format");
        }

        #[test]
        fn equality() {
            let id1 = FixId::new("issue", "fix", "key");
            let id2 = FixId::new("issue", "fix", "key");
            assert_eq!(id1, id2);
        }
    }

    mod ref_change {
        use super::*;

        #[test]
        fn create_display() {
            let change = RefChange::Create {
                ref_name: "refs/heads/main".to_string(),
                new_oid: "abc123def456".to_string(),
            };
            assert!(format!("{}", change).contains("create"));
            assert!(format!("{}", change).contains("refs/heads/main"));
        }

        #[test]
        fn update_display() {
            let change = RefChange::Update {
                ref_name: "refs/heads/main".to_string(),
                old_oid: Some("old12345".to_string()),
                new_oid: "new12345".to_string(),
            };
            assert!(format!("{}", change).contains("update"));
        }

        #[test]
        fn delete_display() {
            let change = RefChange::Delete {
                ref_name: "refs/heads/old".to_string(),
                old_oid: "abc12345".to_string(),
            };
            assert!(format!("{}", change).contains("delete"));
        }
    }

    mod metadata_change {
        use super::*;

        #[test]
        fn create_display() {
            let change = MetadataChange::Create {
                branch: "feature".to_string(),
                description: "tracked branch".to_string(),
            };
            assert!(format!("{}", change).contains("create"));
            assert!(format!("{}", change).contains("feature"));
        }

        #[test]
        fn update_display() {
            let change = MetadataChange::Update {
                branch: "feature".to_string(),
                field: "parent".to_string(),
                old_value: Some("old-parent".to_string()),
                new_value: "new-parent".to_string(),
            };
            assert!(format!("{}", change).contains("update"));
        }

        #[test]
        fn delete_display() {
            let change = MetadataChange::Delete {
                branch: "old-feature".to_string(),
            };
            assert!(format!("{}", change).contains("delete"));
        }
    }

    mod config_change {
        use super::*;

        #[test]
        fn set_display() {
            let change = ConfigChange::Set {
                key: "trunk".to_string(),
                value: "main".to_string(),
            };
            assert!(format!("{}", change).contains("set"));
            assert!(format!("{}", change).contains("trunk"));
        }

        #[test]
        fn remove_display() {
            let change = ConfigChange::Remove {
                key: "old-key".to_string(),
            };
            assert!(format!("{}", change).contains("remove"));
        }

        #[test]
        fn migrate_display() {
            let change = ConfigChange::Migrate {
                from: "old/path".to_string(),
                to: "new/path".to_string(),
            };
            assert!(format!("{}", change).contains("migrate"));
        }
    }

    mod fix_preview {
        use super::*;

        #[test]
        fn new_is_empty() {
            let preview = FixPreview::new();
            assert!(!preview.has_changes());
            assert_eq!(preview.change_count(), 0);
        }

        #[test]
        fn with_summary() {
            let preview = FixPreview::with_summary("Test summary");
            assert_eq!(preview.summary, "Test summary");
        }

        #[test]
        fn add_ref_change() {
            let preview = FixPreview::new().add_ref_change(RefChange::Create {
                ref_name: "refs/heads/test".to_string(),
                new_oid: "abc123".to_string(),
            });
            assert!(preview.has_changes());
            assert_eq!(preview.change_count(), 1);
        }

        #[test]
        fn add_metadata_change() {
            let preview = FixPreview::new().add_metadata_change(MetadataChange::Delete {
                branch: "test".to_string(),
            });
            assert!(preview.has_changes());
            assert_eq!(preview.change_count(), 1);
        }

        #[test]
        fn add_config_change() {
            let preview = FixPreview::new().add_config_change(ConfigChange::Set {
                key: "test".to_string(),
                value: "value".to_string(),
            });
            assert!(preview.has_changes());
            assert_eq!(preview.change_count(), 1);
        }

        #[test]
        fn format_includes_all_sections() {
            let preview = FixPreview::with_summary("Summary")
                .add_ref_change(RefChange::Create {
                    ref_name: "refs/heads/test".to_string(),
                    new_oid: "abc123".to_string(),
                })
                .add_metadata_change(MetadataChange::Delete {
                    branch: "test".to_string(),
                })
                .add_config_change(ConfigChange::Set {
                    key: "key".to_string(),
                    value: "value".to_string(),
                });

            let formatted = preview.format();
            assert!(formatted.contains("Summary"));
            assert!(formatted.contains("Ref changes"));
            assert!(formatted.contains("Metadata changes"));
            assert!(formatted.contains("Config changes"));
        }
    }

    mod fix_option {
        use super::*;

        #[test]
        fn new() {
            let fix = FixOption::new(
                FixId::simple("issue", "fix"),
                IssueId::singleton("issue"),
                "Test fix",
                FixPreview::new(),
            );
            assert_eq!(fix.description, "Test fix");
            assert!(fix.preconditions.is_empty());
            assert!(!fix.has_plan());
        }

        #[test]
        fn with_precondition() {
            let fix = FixOption::new(
                FixId::simple("issue", "fix"),
                IssueId::singleton("issue"),
                "Test",
                FixPreview::new(),
            )
            .with_precondition(Capability::RepoOpen);

            assert_eq!(fix.preconditions.len(), 1);
            assert_eq!(fix.preconditions[0], Capability::RepoOpen);
        }

        #[test]
        fn with_preconditions() {
            let fix = FixOption::new(
                FixId::simple("issue", "fix"),
                IssueId::singleton("issue"),
                "Test",
                FixPreview::new(),
            )
            .with_preconditions([Capability::RepoOpen, Capability::TrunkKnown]);

            assert_eq!(fix.preconditions.len(), 2);
        }

        #[test]
        fn preconditions_satisfied() {
            use crate::engine::capabilities::CapabilitySet;

            let fix = FixOption::new(
                FixId::simple("issue", "fix"),
                IssueId::singleton("issue"),
                "Test",
                FixPreview::new(),
            )
            .with_precondition(Capability::RepoOpen);

            let mut caps = CapabilitySet::new();
            assert!(!fix.preconditions_satisfied(&caps));

            caps.insert(Capability::RepoOpen);
            assert!(fix.preconditions_satisfied(&caps));
        }
    }
}
